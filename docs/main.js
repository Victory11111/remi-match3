/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style.css":
/*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style.css ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `html * {\r\n    box-sizing: border-box;\r\n    user-select: none;\r\n}\r\n\r\nbody {\r\n    padding: 20px;\r\n    margin: 0;\r\n    font-family: \"Exo 2\", sans-serif;\r\n    box-sizing: border-box;\r\n}\r\n\r\n.title {\r\n    font-size: 24px;\r\n    text-align: center;\r\n}\r\n\r\n.mainmenu__list {\r\n    padding: 0;\r\n    margin: 0;\r\n    list-style: none;\r\n    border: 1px gray solid;\r\n    display: flex;\r\n}\r\n\r\n.mainmenu li {\r\n    list-style: none;\r\n}\r\n\r\n.mainmenu__link {\r\n    display: block;\r\n    padding: 10px 25px;\r\n    color: #000;\r\n    text-decoration: none;\r\n}\r\n\r\n.mainmenu__link:hover {\r\n    text-decoration: none;\r\n    background-color: darkgray;\r\n    color: #fff;\r\n}\r\n\r\n.mainmenu__link.active {\r\n    text-decoration: none;\r\n    background-color: #000;\r\n    color: #fff;\r\n}\r\n\r\n.content {\r\n    max-width: fit-content;\r\n    padding: 1.5em 0;\r\n    margin: auto;\r\n\r\n}\r\n\r\n\r\n.blue {\r\n    width: 500px;\r\n    height: 200px;\r\n    background-color: aquamarine;\r\n}\r\n\r\n.hidden {\r\n    display: none;\r\n}\r\n\r\n.levelIcons {\r\n    margin: auto;\r\n    display: flex;\r\n    justify-content: center;\r\n    gap: 15px;\r\n    flex-wrap: wrap;\r\n}\r\n\r\n.levelIcon {\r\n    width: 50px;\r\n    height: 50px;\r\n    background-color: gainsboro;\r\n    border-radius: 15%;\r\n    border: 2px dashed darkgray;\r\n    color: whitesmoke;\r\n    font-size: 30px;\r\n}\r\n\r\n.playfield {\r\n    width: max-content;\r\n    height: max-content;\r\n    background-color: rgb(72, 110, 124);\r\n    display: flex;\r\n    flex-wrap: wrap;\r\n    gap: 5px;\r\n    position: relative;\r\n\r\n}\r\n\r\na.levelIcon {\r\n    text-decoration: none;\r\n    text-align: center;\r\n}\r\n\r\n.element1,\r\n.element2,\r\n.element3,\r\n.element0,\r\n.element4,\r\n.bomb1,\r\n.bomb2 {\r\n    width: 50px;\r\n    height: 50px;\r\n    border-radius: 50%;\r\n    border: 1px solid rgb(255, 255, 255);\r\n    padding: 5px;\r\n    text-align: center;\r\n    position: relative;\r\n    /* Важно для абсолютного позиционирования */\r\n    transition: transform 0.3s ease;\r\n    will-change: transform;\r\n    /* Время и анимация перестановки */\r\n    z-index: 1;\r\n    /* Обеспечиваем, что элементы отображаются поверх друг друга при перемещении */\r\n    /* Плавное изменение прозрачности */\r\n\r\n}\r\n\r\n.invisible {\r\n\r\n    opacity: 0;\r\n    pointer-events: none;\r\n    /* Предотвращает взаимодействие с элементом после исчезновения */\r\n}\r\n\r\n.element1 {\r\n    background-color: aqua;\r\n\r\n}\r\n\r\n.element2 {\r\n    background-color: magenta;\r\n}\r\n\r\n.element3 {\r\n    background-color: yellow;\r\n}\r\n\r\n.element0 {\r\n    background-color: greenyellow;\r\n}\r\n\r\n.element4 {\r\n    background-color: rgb(167, 167, 167);\r\n}\r\n\r\n.falling {\r\n    /* position: absolute; */\r\n    position: relative;\r\n    /* transform: scale(0.00001); */\r\n    z-index: 2;\r\n    transition: transform 0.3s ease-in-out;\r\n}\r\n\r\n.red {\r\n    /* background-color: rgb(145, 145, 245); */\r\n    animation: uuu 2s ease-out forwards;\r\n}\r\n\r\n\r\n\r\n.grid-item.moving {\r\n    z-index: 2;\r\n    /* Элемент, который двигается, должен быть выше */\r\n}\r\n\r\n.bomb2 {\r\n    background-color: rgb(255, 0, 0);\r\n}\r\n\r\n.bomb1 {\r\n    background-color: rgb(255, 140, 8);\r\n}\r\n\r\n@keyframes fakeExplosion {\r\n    0% {\r\n        background-color: yellow;\r\n    }\r\n\r\n    50% {\r\n        background-color: red;\r\n    }\r\n\r\n    100% {\r\n        background-color: transparent;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n@keyframes uuu {\r\n    0% {\r\n        background-color: green;\r\n    }\r\n\r\n    50% {\r\n        background-color: blue;\r\n    }\r\n\r\n    100% {\r\n        background-color: transparent;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n.KABOOM {\r\n    animation: fakeExplosion 0.5s ease-out forwards;\r\n}\r\n\r\n.locked{\r\n    background-color: rgb(0, 76, 42);\r\n    pointer-events: none;\r\n}`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://remi_match3_game/./src/style.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://remi_match3_game/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://remi_match3_game/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://remi_match3_game/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://remi_match3_game/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://remi_match3_game/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://remi_match3_game/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://remi_match3_game/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://remi_match3_game/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.css */ \"./src/style.css\");\n\r\n\r\n/* ----- spa init module --- */\r\nconst mySPA = (function () {\r\n\r\n    /* ------- begin view -------- */\r\n    function ModuleView() {\r\n        let myModuleContainer = null;\r\n        let menu = null;\r\n        let contentContainer = null;\r\n        let rows = null;\r\n        let colls = null;\r\n        let arr = null;\r\n        let matched = []\r\n        let above = []\r\n        this.playfield = null;\r\n\r\n        const HomeComponent = {\r\n            id: \"main\",\r\n            title: \"Главная страница примера SPA\",\r\n            render: (className = \"container\") => {\r\n                return `\r\n          <section class=\"${className}\">\r\n            <h1>Главная</h1>\r\n            <p>Здесь будет контент <strong>Главной</strong> страницы.</p>\r\n          </section>\r\n        `;\r\n            }\r\n        };\r\n\r\n        const RulesComponent = {\r\n            id: \"rules\",\r\n            title: \"Правила игры\",\r\n            render: (className = \"container\") => {\r\n                return `\r\n          <section class=\"${className}\">\r\n            <h1>Правила</h1>\r\n            <p>Правила игры</p>\r\n          </section>\r\n        `;\r\n            }\r\n        };\r\n\r\n        const LevelsComponent = {\r\n            id: \"levels\",\r\n            title: \"Уровни\",\r\n            render: (className = \"container\") => {\r\n                return `\r\n          <section class=\"${className}\">\r\n            <h1>Уровни</h1>\r\n            <p>Выбор уровня игры</p>\r\n         <div class=\"levelIcons\">\r\n            <a class=\"levelIcon\" href=\"#first_level\">1</a>\r\n            <a class=\"levelIcon\" href=\"#second_level\">2</a>\r\n            <a class=\"levelIcon\" href=\"#third_level\">3</a>\r\n            </div>\r\n          </section>\r\n        `;\r\n            }\r\n        };\r\n\r\n        const SignUpComponent = {\r\n            id: \"sign_up\",\r\n            title: \"Регистрация\",\r\n            render: (className = \"container\") => {\r\n                return `\r\n          <section class=\"${className}\">\r\n            <h1>Регистрация</h1>\r\n            <p>Зарегайся</p>\r\n          </section>\r\n        `;\r\n            }\r\n        };\r\n\r\n        const LogInComponent = {\r\n            id: \"log_in\",\r\n            title: \"Вход\",\r\n            render: (className = \"container\") => {\r\n                return `\r\n          <section class=\"${className}\">\r\n            <h1>Вход</h1>\r\n            <p>Войти</p>\r\n          </section>\r\n        `;\r\n            }\r\n        };\r\n\r\n        const ErrorComponent = {\r\n            id: \"error\",\r\n            title: \"Achtung, warning, kujdes, attenzione, pozornost...\",\r\n            render: (className = \"container\") => {\r\n                return `\r\n          <section class=\"${className}\">\r\n            <h1>Ошибка 404</h1>\r\n            <p>Страница не найдена, попробуйте вернуться на <a href=\"#main\">главную</a>.</p>\r\n          </section>\r\n        `;\r\n            }\r\n        };\r\n\r\n\r\n        this.createLevel = function (id, title, content) {\r\n            return {\r\n                id,\r\n                title,\r\n                render: (className = \"container\") => {\r\n                    return `\r\n                        <section class=\"${className}\">\r\n                        <p>${content}</p>\r\n                        <div class='playfield'></div>\r\n                        </section>`;\r\n                }\r\n            };\r\n        }\r\n\r\n        const firstLevel = this.createLevel(1, \"1_level\", \"первый лвл\")\r\n        const secondLevel = this.createLevel(2, \"2_level\", \"второй лвл\")\r\n        const thirdLevel = this.createLevel(3, \"3_level\", \"третий лвл\")\r\n\r\n        const router = {\r\n            main: HomeComponent,\r\n            rules: RulesComponent,\r\n            levels: LevelsComponent,\r\n            default: HomeComponent,\r\n            sign_up: SignUpComponent,\r\n            log_in: LogInComponent,\r\n            error: ErrorComponent,\r\n            first_level: firstLevel,\r\n            second_level: secondLevel,\r\n            third_level: thirdLevel,\r\n        };\r\n\r\n        this.init = function (container) {\r\n            myModuleContainer = container;\r\n            menu = myModuleContainer.querySelector(\"#mainmenu\");\r\n            contentContainer = myModuleContainer.querySelector(\"#content\");\r\n        }\r\n\r\n        this.updateButtons = function (currentPage) {\r\n            const menuLinks = menu.querySelectorAll(\".mainmenu__link\");\r\n            const state = `#${currentPage}`;\r\n\r\n            for (let link of menuLinks) {\r\n                state === link.getAttribute(\"href\") ? link.classList.add(\"active\") : link.classList.remove(\"active\");\r\n            }\r\n\r\n        }\r\n\r\n        this.renderContent = function (hashPageName) {\r\n            let routeName = \"default\";\r\n\r\n            if (hashPageName.length > 0) {\r\n                routeName = hashPageName in router ? hashPageName : \"error\";\r\n            }\r\n\r\n            window.document.title = router[routeName].title;\r\n            contentContainer.innerHTML = router[routeName].render(`${routeName}-page`);\r\n            this.updateButtons(router[routeName].id);\r\n        }\r\n\r\n        this.getElementByOrder = function (order) { // возвращает элемент с указанным порядковым номером\r\n            return Array.from(document.querySelectorAll('[form]'))\r\n                .find(el => +el.style.order === order);\r\n        }\r\n\r\n        this.createABoard = function (rows, cols, arr) {\r\n            this.playfield = document.querySelector('.playfield')\r\n            this.playfield.style.display = 'grid';\r\n            this.playfield.setAttribute('rows', rows)\r\n            this.playfield.setAttribute('cols', cols)\r\n            this.playfield.style.gridTemplateColumns = 'repeat(' + cols + ', 1fr)'; // Определяем структуру сетки\r\n            for (let i = 0; i < arr.length; i++) {\r\n                const cell = document.createElement('div');\r\n                // cell.id = i;\r\n                cell.style.order = i;\r\n                cell.textContent = arr[i];\r\n                cell.setAttribute('form', arr[i])\r\n                cell.classList.add('element' + arr[i])\r\n                this.playfield.appendChild(cell);\r\n            }\r\n        }\r\n\r\n        this.getElementByOrder = function (order) { // возвращает элемент с указанным порядковым номером\r\n            return Array.from(document.querySelectorAll('[form]'))\r\n                .find(el => +el.style.order === order);\r\n        }\r\n\r\n        this.getCurrentFormsArray = function () {\r\n            const elements = document.querySelectorAll('[form]');\r\n            const orderedArr = [];\r\n\r\n            elements.forEach(el => {\r\n                const order = +el.style.order;\r\n                const form = +el.getAttribute('form');\r\n                if (!isNaN(order)) {\r\n                    orderedArr[order] = form;\r\n                }\r\n            });\r\n\r\n            return orderedArr;\r\n        };\r\n\r\n\r\n        this.liftAndDropMatchedElements = function (mergedMatches) {\r\n\r\n            const view = this;\r\n            const liftedOrders = mergedMatches.flat();\r\n\r\n            liftedOrders.forEach(order => {\r\n\r\n                const el = this.getElementByOrder(order);\r\n                if (!el) return;\r\n\r\n                const cellHeight = el.offsetHeight;\r\n\r\n                el.setAttribute('data-lifted', 'true');\r\n                el.style.transition = 'none';\r\n                el.style.transform = `translateY(-${cellHeight}px)`;\r\n                el.style.opacity = '0';\r\n\r\n                // requestAnimationFrame(() => {\r\n                //     el.style.transition = 'transform 0.3s ease, opacity 0.3s ease';\r\n                //     el.style.transform = 'translateY(0)';\r\n                //     el.style.opacity = '1';\r\n                // });\r\n            });\r\n        };\r\n\r\n        this.showNoSwipes = function (startOrder, endOrder) {\r\n            return new Promise(resolve => {\r\n                const el1 = this.getElementByOrder(startOrder);\r\n                const el2 = this.getElementByOrder(endOrder);\r\n                el2.style.transition = 'none'\r\n                el1.style.transition = 'none'\r\n                if (!el1 || !el2) return resolve();\r\n\r\n                const rect1 = el1.getBoundingClientRect();\r\n                const rect2 = el2.getBoundingClientRect();\r\n\r\n                const dx = rect2.left - rect1.left;\r\n                const dy = rect2.top - rect1.top;\r\n\r\n                // Свайп: элементы движутся навстречу друг другу\r\n                el1.style.transition = 'transform 200ms ease';\r\n                el2.style.transition = 'transform 200ms ease';\r\n                el1.style.transform = `translate(${dx}px, ${dy}px)`;\r\n                el2.style.transform = `translate(${-dx}px, ${-dy}px)`;\r\n\r\n                setTimeout(() => {\r\n                    el1.style.transition = '';\r\n                    el2.style.transition = '';\r\n                    // Первый кадр — сброс transition\r\n                    // Второй кадр — сброс transform (теперь уже без анимации)\r\n                    requestAnimationFrame(() => {\r\n                        requestAnimationFrame(() => {\r\n                            el1.style.transform = '';\r\n                            el2.style.transform = '';\r\n                            resolve();\r\n                        });\r\n                    });\r\n                }, 250);\r\n            });\r\n        };\r\n\r\n        this.showSwipes = function (startOrder, endOrder) {\r\n\r\n            this.playfield.classList.add('locked')\r\n  \r\n            return new Promise(resolve => {\r\n                const elA = this.getElementByOrder(startOrder);\r\n                const elB = this.getElementByOrder(endOrder);\r\n                if (!elA || !elB) {\r\n                    this.playfield.classList.remove('locked')\r\n                    return resolve();\r\n                }\r\n\r\n                const rectA = elA.getBoundingClientRect();\r\n                const rectB = elB.getBoundingClientRect();\r\n\r\n                // 1. Мгновенно меняем order, до начала анимации\r\n                elA.style.order = endOrder;\r\n                elB.style.order = startOrder;\r\n\r\n                // 2. Получаем новые координаты после смены order\r\n                const newRectA = elA.getBoundingClientRect();\r\n                const newRectB = elB.getBoundingClientRect();\r\n\r\n                // 3. Считаем обратный сдвиг — откуда были\r\n                const offsetAX = rectA.left - newRectA.left;\r\n                const offsetAY = rectA.top - newRectA.top;\r\n                const offsetBX = rectB.left - newRectB.left;\r\n                const offsetBY = rectB.top - newRectB.top;\r\n\r\n                // 4. Устанавливаем начальный transform и убираем transition\r\n                elA.style.transition = 'none';\r\n                elB.style.transition = 'none';\r\n                elA.style.transform = `translate(${offsetAX}px, ${offsetAY}px)`;\r\n                elB.style.transform = `translate(${offsetBX}px, ${offsetBY}px)`;\r\n\r\n                // 5. Следующий кадр — запускаем плавное движение в новые места\r\n                requestAnimationFrame(() => {\r\n                    elA.style.transition = 'transform 200ms ease';\r\n                    elB.style.transition = 'transform 200ms ease';\r\n                    elA.style.transform = 'translate(0, 0)';\r\n                    elB.style.transform = 'translate(0, 0)';\r\n                });\r\n\r\n                // 6. По завершении анимации — чистим\r\n                setTimeout(() => {\r\n                    elA.style.transition = '';\r\n                    elB.style.transition = '';\r\n                    elA.style.transform = '';\r\n                    elB.style.transform = '';\r\n                    this.playfield.classList.remove('locked')\r\n                    resolve();\r\n                }, 200);\r\n            });\r\n\r\n        };\r\n\r\n        this.animateFallAndRise = function (ordersToDrop, ordersToUp, columnsBefore, columnsAfter) {\r\n            return new Promise(resolve => {\r\n                const duration = 600;\r\n                this.playfield.classList.add('locked')\r\n                // const noShift = columnsBefore.every((val, i) => val === columnsAfter[i]);\r\n                // if (noShift) {\r\n                //     for (let order of ordersToUp) {\r\n                //         const el = this.getElementByOrder(order);\r\n                //         if (el) {\r\n                //             // el.classList.add('red');\r\n                //         }\r\n                //     }\r\n                //     return resolve();\r\n                // }\r\n\r\n                const elements = columnsAfter.map(order => this.getElementByOrder(order));\r\n                const initialRects = elements.map(el => el?.getBoundingClientRect());\r\n           \r\n                // Поднимаемые делаем невидимыми (или красим)\r\n                if (ordersToUp !== 0) { // при взрыве бомбы не вызывается\r\n                    for (let order of ordersToUp) {\r\n                        const el = this.getElementByOrder(order);\r\n                        if (el && !el.getAttribute('form')?.includes('bomb')) {\r\n            \r\n                            // el.classList.add('invisible');\r\n\r\n                            el.classList.add('red');\r\n\r\n                        }\r\n                    }\r\n                }\r\n                // Назначаем старые позиции\r\n               \r\n\r\n                const timerId = setTimeout(() => {\r\n                    for (let i = 0; i < elements.length; i++) {\r\n                    if (elements[i]) {\r\n                        elements[i].style.order = columnsBefore[i];\r\n                    }\r\n                }\r\n\r\n                requestAnimationFrame(() => {\r\n                    for (let i = 0; i < elements.length; i++) {\r\n                        const el = elements[i];\r\n                        if (!el) continue;\r\n\r\n                        const newRect = el.getBoundingClientRect();\r\n                        const dx = initialRects[i].left - newRect.left;\r\n                        const dy = initialRects[i].top - newRect.top;\r\n\r\n                        el.style.transition = 'none';\r\n                        el.style.transform = `translate(${dx}px, ${dy}px)`;\r\n                    }\r\n\r\n                    requestAnimationFrame(() => {\r\n                        for (let el of elements) {\r\n                            if (!el) continue;\r\n                            el.style.transition = `transform ${duration}ms ease`;\r\n                            el.style.transform = 'translate(0, 0)';\r\n                        }\r\n\r\n                        setTimeout(() => {\r\n                            for (let el of elements) {\r\n                                if (!el) continue;\r\n                                el.style.transition = '';\r\n                                el.style.transform = '';\r\n                            }\r\n\r\n                            // Удаляем класс только с падающих\r\n                            document.querySelectorAll('.red').forEach(el => {\r\n                                el.classList.remove('red');\r\n                              });\r\n                            this.playfield.classList.remove('locked')\r\n                            resolve();\r\n                        }, duration);\r\n                    });\r\n                });\r\n\r\n\r\n\r\n                  }, 2000)\r\n                  \r\n\r\n\r\n            });\r\n        };\r\n\r\n        this.addNewElements = function (arr, newOrdersOfMatchedElements) {\r\n            this.playfield.classList.add('locked')\r\n\r\n           \r\n            // Сохраняем dom-элементы до любых потенциальных изменений order\r\n            const domElements = newOrdersOfMatchedElements.map(order => ({\r\n                order,\r\n                el: this.getElementByOrder(order)\r\n            }));\r\n\r\n            // Устанавливаем form и innerText каждому из них\r\n            for (const { order, el } of domElements) {\r\n                if (!el) continue;\r\n                el.className = 'element' + arr[order]\r\n                if (el.hasAttribute('bomb')) { el.removeAttribute('bomb') }\r\n                el.setAttribute('form', arr[order]);\r\n                el.innerText = arr[order];\r\n            }\r\n            this.playfield.classList.remove('locked')\r\n        }\r\n\r\n        this.redrawBoard = function (arr) {\r\n            this.playfield.classList.add('locked')\r\n\r\n            arr.forEach((form, index) => {\r\n                const element = this.getElementByOrder(index);\r\n\r\n                if (element) {\r\n                    element.setAttribute('form', form);\r\n                    element.innerHTML = form\r\n                    element.classList = 'element' + form\r\n                }\r\n            });\r\n            this.playfield.classList.remove('locked')\r\n        };\r\n\r\n        this.addBombs = function (arr, bombs, newBombOrders) {\r\n            this.playfield.classList.add('locked')\r\n\r\n      \r\n            // for (let r = 0; r < this.rows; r++) {\r\n            //     const row = arr.slice(r * this.cols, (r + 1) * this.cols);\r\n            //     console.log(row.join(' '));\r\n            // }\r\n\r\n            return new Promise((resolve) => {\r\n                bombs.forEach((el, i) => {\r\n\r\n                    this.getElementByOrder(el).className = arr[newBombOrders[i]];\r\n                    this.getElementByOrder(el).setAttribute('form', arr[newBombOrders[i]]);\r\n                    this.getElementByOrder(el).setAttribute('bomb', arr[newBombOrders[i]]);\r\n                    this.getElementByOrder(el).innerText = arr[newBombOrders[i]]\r\n                });\r\n                this.playfield.classList.remove('locked')\r\n                resolve(); // Завершаем промис в любом случае\r\n            });\r\n\r\n        }\r\n\r\n        this.animateBomb = function (startOrder) {\r\n            this.playfield.classList.add('locked')\r\n            return new Promise(resolve => {\r\n                // Твоя анимация старта взрыва\r\n                const bomb = this.getElementByOrder(startOrder)\r\n\r\n\r\n                bomb.classList.add('KABOOM')\r\n                // Ставишь таймер на продолжительность анимации\r\n                setTimeout(() => {\r\n                    // После окончания анимации убираешь класс (если нужно)\r\n                    bomb.classList.remove('KABOOM');\r\n                    bomb.classList.add('invisible');\r\n                    this.playfield.classList.remove('locked')\r\n                    resolve(); // Важно! Говорим, что всё, взрыв бомбы закончен\r\n                }, 500); // допустим, анимация длится 500 мс\r\n            });\r\n\r\n        }\r\n\r\n        this.animateAffected = function (normalOrders) {\r\n            this.playfield.classList.add('locked')\r\n            return new Promise(resolve => {\r\n                // Твоя анимация старта взрыва\r\n                normalOrders.forEach((el, i) => {\r\n                    const element = this.getElementByOrder(normalOrders[i])\r\n\r\n                    element.classList.add('KABOOM')\r\n                    setTimeout(() => {\r\n                        // После окончания анимации убираешь класс (если нужно)\r\n                        element.classList.remove('KABOOM');\r\n                        element.classList.add('invisible');\r\n                        this.playfield.classList.remove('locked')\r\n                        resolve(); // Важно! Говорим, что всё, взрыв бомбы закончен\r\n                    }, 500);\r\n\r\n                })\r\n            });\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    };\r\n    /* -------- end view --------- */\r\n    /* ------- begin model ------- */\r\n    function ModuleModel() {\r\n        let myModuleView = null;\r\n        let arr = null; // массив с элементами для игрового поля\r\n        this.rows = 0; // количество строк элементов на игровом поле\r\n        this.cols = 0; // количество столбцов элементов на игровом поле\r\n        this.amountOfTypesOfElements = 0 // колияество видов элементов\r\n        this.bombTypes = ['bomb1', 'bomb2']\r\n        this.bombConfigs = {\r\n            bomb1: { power: 1 },\r\n            bomb2: { power: 2 },\r\n            bomb3: { power: 3 }\r\n        };\r\n        this.init = function (view) {\r\n            myModuleView = view;\r\n        }\r\n\r\n        this.levelConfigs = {\r\n            first: { rows: 8, cols: 6, types: 5 },\r\n            second: { rows: 10, cols: 8, types: 5 },\r\n            third: { rows: 12, cols: 9, types: 5 }\r\n        };\r\n\r\n        this.updateState = function (hashPageName) { // вызов функции отрисовки игрового поля при выборе уровня\r\n            myModuleView.renderContent(hashPageName);\r\n            if (hashPageName.includes('_level')) {\r\n                const level = hashPageName.replace('_level', '');\r\n                const config = this.levelConfigs[level];\r\n                if (config) {\r\n                    this.rows = config.rows;\r\n                    this.cols = config.cols;\r\n                    this.amountOfTypesOfElements = config.types;\r\n                    this.createLevel(this.rows, this.cols, this.amountOfTypesOfElements);\r\n                }\r\n            }\r\n        };\r\n\r\n        this.createOriginalGrid = function (rows, cols, amountOfTypesOfElements) {\r\n            this.rows = rows\r\n            this.cols = cols\r\n            this.amountOfTypesOfElements = amountOfTypesOfElements\r\n            return this.original = this.createAnArray(this.rows, this.cols, this.amountOfTypesOfElements);\r\n        }\r\n\r\n        this.getGridCopy = function () {\r\n            return [...this.original]; // создаём независимую копию\r\n        }\r\n\r\n        this.synchronize = function (arr) {\r\n            this.original = [...arr]; // копируем значения из arr\r\n        }\r\n\r\n        this.createLevel = function (rows, cols, amountOfTypesOfElements) {\r\n            this.original = this.createOriginalGrid(rows, cols, amountOfTypesOfElements) // получение массива для заполнения игрового поля с учётом выбранного размера сетки элементов\r\n            myModuleView.createABoard(rows, cols, this.original)\r\n            // this.logGrid(this.original, rows, this.cols)\r\n            return arr;\r\n        }\r\n\r\n        this.pickAForm = function (amountOfTypesOfElements) {\r\n            return Math.floor(Math.random() * amountOfTypesOfElements) + 1; // функция для рандомного выбора вида игровых элементов\r\n        }\r\n\r\n        this.getSmartRandomForm = function (arr, amountOfRorms) {\r\n            const formCounts = new Array(amountOfRorms).fill(0);\r\n\r\n            arr.forEach(f => {\r\n                if (f >= 0 && f < amountOfRorms) formCounts[f]++;\r\n            });\r\n\r\n            const maxCount = Math.max(...formCounts);\r\n            const invertedWeights = formCounts.map(c => maxCount - c + 1);\r\n\r\n            const totalWeight = invertedWeights.reduce((a, b) => a + b);\r\n            const r = Math.random() * totalWeight;\r\n            let sum = 0;\r\n\r\n            for (let i = 0; i < invertedWeights.length; i++) {\r\n                sum += invertedWeights[i];\r\n                if (r < sum) return i;\r\n            }\r\n\r\n            return amountOfRorms - 1; // fallback, почти невозможен\r\n        };\r\n\r\n        this.createAnArray = function (rows, cols, amountOfTypesOfElements) {\r\n\r\n            // let arr = [ //  пример 1 - при сайпе 2 бомбы в горизонтале\r\n            //     0, 2, 2, 3, 2, 2,\r\n            //     1, 3, 3, 2, 3, 3,\r\n            //     0, 1, 0, 1, 0, 1,\r\n            //     0, 2, 2, 3, 2, 2,\r\n            //     1, 3, 3, 2, 3, 3,\r\n            //     1, 3, 3, 2, 3, 3,\r\n            //     0, 1, 0, 1, 0, 1,\r\n            //     1, 0, 1, 0, 1, 0\r\n            // ]\r\n\r\n            // let arr = [//  пример 2 - при сайпе бомба Г лежит на потолке\r\n            //     0, 1, 2, 2, 0, 2,\r\n            //     1, 0, 1, 0, 2, 0,\r\n            //     0, 1, 0, 1, 2, 1,\r\n            //     1, 0, 1, 0, 1, 0,\r\n            //     0, 1, 0, 1, 0, 1,\r\n            //     1, 0, 1, 0, 1, 0,\r\n            //     0, 1, 0, 1, 0, 1,\r\n            //     1, 0, 1, 0, 1, 0,\r\n            // ]\r\n\r\n\r\n            // let arr = [ //пример 3 - при сайпе бомба L упирается в потолок, колонка упирается в потолок\r\n            //     0, 2, 0, 1, 0, 1,\r\n            //     1, 2, 1, 0, 1, 0,\r\n            //     2, 3, 2, 2, 0, 1,\r\n            //     1, 0, 1, 0, 1, 0,\r\n            //     0, 1, 0, 1, 0, 1,\r\n            //     1, 0, 1, 0, 1, 0,\r\n            //     0, 1, 0, 1, 0, 1,\r\n            //     1, 0, 1, 0, 1, 0,\r\n            // ]\r\n\r\n\r\n            // let arr = [//  пример 4 - при сайпе 2 колонки упираются в потолок\r\n            //     0, 1, 0, 1, 0, 3,\r\n            //     1, 0, 1, 0, 0, 3,\r\n            //     0, 1, 0, 1, 3, 0,\r\n            //     1, 0, 1, 0, 0, 3,\r\n            //     0, 1, 0, 1, 0, 3,\r\n            //     1, 0, 1, 0, 1, 0,\r\n            //     0, 1, 0, 1, 0, 1,\r\n            //     1, 0, 1, 0, 1, 0,\r\n            // ]\r\n\r\n            let arr = [//  пример 5 - при сайпе появляется \"Т\" большая бомба и упирается в потолок боком\r\n                0, 3, 0, 1, 0, 1,\r\n                1, 3, 1, 0, 1, 0,\r\n                3, 2, 3, 3, 0, 1,\r\n                1, 3, 1, 0, 1, 0,\r\n                0, 3, 0, 1, 0, 1,\r\n                1, 0, 1, 0, 1, 0,\r\n                0, 1, 0, 1, 0, 1,\r\n                1, 0, 1, 0, 1, 0,\r\n            ]\r\n\r\n\r\n            // let arr = [//  пример 6 - при сайпе \"Т\" появляется большая бомба и упирается в потолок \r\n            //     0, 1, 3, 1, 0, 1,\r\n            //     1, 0, 3, 0, 1, 0,\r\n            //     3, 3, 2, 3, 3, 1,\r\n            //     1, 0, 3, 0, 1, 0,\r\n            //     0, 1, 0, 1, 0, 1,\r\n            //     1, 0, 1, 0, 1, 0,\r\n            //     0, 1, 0, 1, 0, 1,\r\n            //     1, 0, 1, 0, 1, 0,\r\n            // ]\r\n\r\n            // let arr = [//  пример 7 - при сайпе появляется бомба 1 первом ряду \r\n            //     0, 2, 2, 3, 2, 2,\r\n            //     1, 0, 1, 2, 1, 0,\r\n            //     1, 0, 1, 0, 1, 0,\r\n            //     0, 1, 0, 1, 0, 1,\r\n            //     0, 1, 0, 1, 0, 1,\r\n            //     1, 0, 1, 0, 1, 0,\r\n            //     1, 0, 1, 0, 1, 0,\r\n            //     0, 1, 0, 1, 0, 1,\r\n\r\n            // ]\r\n            // let arr = [//  пример 8 - уже есть 1 бомба \r\n            //     1, 0, 1, 0, 1, 0,\r\n            //     0, 1, 0, 1, 0, 1,\r\n            //     1, 0, 1, 0, 1, 0,\r\n            //     0, 1, 'bomb1', 1, 0, 1,\r\n            //     1, 0, 1, 0, 1, 0,\r\n            //     0, 1, 0, 1, 0, 1,\r\n\r\n            // ]\r\n\r\n\r\n            // let arr = [// пример 9 - после всего свайпа должна сложиться бомба\r\n            //     0, 1, 0, 2, 0, 1,\r\n            //     1, 0, 1, 0, 1, 0,\r\n            //     0, 1, 0, 1, 0, 1,\r\n            //     1, 2, 2, 0, 2, 2,\r\n            //     0, 1, 0, 1, 0, 1,\r\n            //     1, 0, 1, 0, 1, 0\r\n            // ]\r\n\r\n            // let arr = [// пример 10 - после всего свайпа должна сложиться бомба\r\n            //     0, 1, 0, 1, 0, 1,\r\n            //     1, 0, 1, 0, 1, 0,\r\n            //     0, 1, 2, 1, 0, 1,\r\n            //     2, 2, 3, 3, 1, 3,\r\n            //     0, 1, 2, 1, 0, 1,\r\n            //     1, 0, 2, 0, 1, 0\r\n            // ]\r\n\r\n\r\n            // 0, 1, 0, 1, 0, 1,\r\n            // 1, 0, 1, 0, 1, 0,\r\n            // 0, 1, 0, 1, 0, 1,\r\n            // 1, 0, 1, 0, 1, 0,\r\n            // 0, 1, 0, 1, 0, 1,\r\n            // 1, 0, 1, 0, 1, 0\r\n\r\n\r\n            // let arr = [ // пример 10 - при свайпе 3 бомбы падают в ряд\r\n            //     0, 2, 2, 3, 2, 2,\r\n            //     1, 3, 3, 2, 3, 3,\r\n            //     2, 3, 'bomb1', 0, 1, 2,\r\n            //     'bomb1', 'bomb1', 2, 3, 3, 2,\r\n            //     4, 0, 3, 0, 3, 4,\r\n            //     0, 1, 2, 3, 4, 0,\r\n            //     1, 3, 1, 4, 4, 1,\r\n            //     0, 1, 2, 3, 2, 0,\r\n            // ];\r\n\r\n            // let arr = [\r\n            //     0, 1, 2, 3, 4, 0,\r\n            //     1, 2, 3, 4, 0, 1,\r\n            //     2, 3, 4, 0, 1, 2,\r\n            //     3, 4, 0, 1, 2, 3,\r\n            //     4, 0, 1, 2, 3, 4,\r\n            //     0, 1, 2, 3, 4, 0\r\n            // ];\r\n\r\n\r\n            for (let i = 0; i < rows * cols; i++) {\r\n                let form;\r\n                do {\r\n                    form = this.getSmartRandomForm(arr, amountOfTypesOfElements);\r\n                } while (this.willCauseMatch(arr, i, form, cols));\r\n                arr[i] = form;\r\n            }\r\n\r\n\r\n            return arr\r\n        }\r\n\r\n        this.willCauseMatch = function (arr, index, form, rows) { // проверка отсутствия совпадений на 1 элемент\r\n            const height = Math.floor(arr.length / rows);\r\n            const row = Math.floor(index / rows);\r\n            const col = index % rows;\r\n\r\n            const check = (i) => i >= 0 && i < arr.length ? arr[i] : null;\r\n\r\n            // Подставим form на это место\r\n            const temp = [...arr];\r\n            temp[index] = form;\r\n\r\n            // Горизонталь\r\n            let hor = 1;\r\n            for (let i = col - 1; i >= 0; i--) {\r\n                if (temp[row * rows + i] === form) hor++;\r\n                else break;\r\n            }\r\n            for (let i = col + 1; i < rows; i++) {\r\n                if (temp[row * rows + i] === form) hor++;\r\n                else break;\r\n            }\r\n            if (hor >= 3) return true;\r\n\r\n            // Вертикаль\r\n            let vert = 1;\r\n            for (let i = row - 1; i >= 0; i--) {\r\n                if (temp[i * rows + col] === form) vert++;\r\n                else break;\r\n            }\r\n            for (let i = row + 1; i < height; i++) {\r\n                if (temp[i * rows + col] === form) vert++;\r\n                else break;\r\n            }\r\n            if (vert >= 3) return true;\r\n            return false;\r\n        }\r\n\r\n        this.swipe = function (startOrder = undefined, endOrder = undefined) {// замена в массиве значений переставленных элементов\r\n\r\n            const arr = this.getGridCopy()\r\n\r\n            // console.log('11111111111111111111111111111111111111111111111111111111111111111111111111')\r\n            // for (let r = 0; r < this.rows; r++) {\r\n            //     const row = arr.slice(r * this.cols, (r + 1) * this.cols);\r\n            //     console.log(row.join(' '));\r\n            // }\r\n\r\n            const formOfFirstElement = arr[startOrder]\r\n            const formOfSecondElement = arr[endOrder]\r\n            arr[startOrder] = formOfSecondElement\r\n            arr[endOrder] = formOfFirstElement\r\n            return this.findRows(arr, startOrder, endOrder)\r\n\r\n        }\r\n\r\n        this.findRows = function (arr, startOrder, endOrder) {\r\n\r\n            // console.log('222222222222222222222222222222222222222222222222222222222222222222')\r\n            // for (let r = 0; r < this.rows; r++) {\r\n            //     const row = arr.slice(r * this.cols, (r + 1) * this.cols);\r\n            //     console.log(row.join(' '));\r\n            // }\r\n            const cols = this.cols;\r\n            const matchedOrders = [];\r\n            const seen = new Set();\r\n            const pointsToCheck = [startOrder, endOrder];\r\n\r\n            // Проверка горизонтали: убеждаемся, что всё в одной строке\r\n            const checkHorizontal = (baseIndex) => {\r\n                const line = [baseIndex];\r\n                const row = Math.floor(baseIndex / cols);\r\n\r\n                let i = baseIndex - 1;\r\n                while (\r\n                    i >= 0 &&\r\n                    arr[i] === arr[baseIndex] &&\r\n                    Math.floor(i / cols) === row\r\n                ) {\r\n                    line.unshift(i);\r\n                    i--;\r\n                }\r\n\r\n                i = baseIndex + 1;\r\n                while (\r\n                    i < arr.length &&\r\n                    arr[i] === arr[baseIndex] &&\r\n                    Math.floor(i / cols) === row\r\n                ) {\r\n                    line.push(i);\r\n                    i++;\r\n                }\r\n\r\n                return line.length >= 3 ? line : null;\r\n            };\r\n\r\n            // Проверка вертикали: идём вверх и вниз по колонке\r\n            const checkVertical = (baseIndex) => {\r\n                const line = [baseIndex];\r\n\r\n                let i = baseIndex - cols;\r\n                while (i >= 0 && arr[i] === arr[baseIndex]) {\r\n                    line.unshift(i);\r\n                    i -= cols;\r\n                }\r\n\r\n                i = baseIndex + cols;\r\n                while (i < arr.length && arr[i] === arr[baseIndex]) {\r\n                    line.push(i);\r\n                    i += cols;\r\n                }\r\n\r\n                return line.length >= 3 ? line : null;\r\n            };\r\n\r\n            for (const point of pointsToCheck) {\r\n                if (!seen.has(point)) {\r\n                    const horizontal = checkHorizontal(point);\r\n                    const vertical = checkVertical(point);\r\n\r\n                    if (horizontal) {\r\n                        horizontal.forEach(i => seen.add(i));\r\n                        matchedOrders.push(horizontal);\r\n                    }\r\n\r\n                    if (vertical) {\r\n                        vertical.forEach(i => seen.add(i));\r\n                        matchedOrders.push(vertical);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (matchedOrders.length) { this.synchronize(arr) }\r\n\r\n            let merged = [];\r\n       \r\n            if (matchedOrders.length > 0) {\r\n                for (const match of matchedOrders) {\r\n                    let toMerge = [];\r\n                    let rest = [];\r\n\r\n                    for (const group of merged) {\r\n                        if (group.some(cell => match.includes(cell))) {\r\n                            toMerge.push(...group);\r\n                        } else {\r\n                            rest.push(group);\r\n                        }\r\n                    }\r\n\r\n                    merged = [...rest, [...new Set([...toMerge, ...match])]];\r\n                }\r\n            }\r\n       \r\n\r\n\r\n\r\n\r\n            // Фильтруем группы с участием бомб, если бомбы есть - не свайпаем\r\n            const filteredMatches = merged.filter(group => {\r\n                return group.every(order => !this.bombTypes.includes(arr[order]));\r\n            });\r\n\r\n            return filteredMatches.length ? this.checkForLines(arr, filteredMatches, startOrder, endOrder) : false;\r\n\r\n\r\n\r\n        };\r\n\r\n        this.checkForLines = function (arr, matchedOrders, startOrder, endOrder) {\r\n\r\n            const newArr = JSON.parse(JSON.stringify(matchedOrders));\r\n    \r\n            const bombs = [];\r\n\r\n\r\n\r\n            if (newArr.some(group => group.length >= 5)) { // ищем бомбы\r\n                for (let group of newArr) {\r\n                    const len = group.length;\r\n                    if (len !== 5 && len !== 6 && len !== 7) continue;\r\n\r\n                    const bombType = len === 7 ? 'bomb2' : 'bomb1';\r\n\r\n                    let bombIndex = startOrder !== undefined && group.includes(startOrder)\r\n                        ? startOrder\r\n                        : startOrder !== undefined && group.includes(endOrder)\r\n                            ? endOrder\r\n                            : group[2];\r\n\r\n                    // group.splice(group.indexOf(bombIndex), 1);\r\n                    arr[bombIndex] = bombType;\r\n                    bombs.push(bombIndex);\r\n                }\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n\r\n            const matchedSet = new Set();\r\n            const aboveSet = new Set();\r\n            let cols = this.cols, rows = this.rows\r\n\r\n            // Соберём все номера из групп в matchedSet\r\n            for (const group of newArr) {\r\n                for (const index of group) {\r\n                    matchedSet.add(index);\r\n                }\r\n            }\r\n    \r\n            // Для каждого совпавшего элемента найдём всё, что выше\r\n            for (const index of matchedSet) {\r\n                let aboveIndex = index - cols;\r\n                while (aboveIndex >= 0) {\r\n                    aboveSet.add(aboveIndex);\r\n                    aboveIndex -= cols;\r\n                }\r\n            }\r\n\r\n            let matched = [...matchedSet].sort((a, b) => a - b),\r\n            above = [...aboveSet].sort((a, b) => a - b)\r\n\r\n            if (above.length > 0) {\r\n\r\n                // this.createcolumnsBefore(startId, endId, above, matched, arr, cols, rows) // allElementsToRedraw = только опускаемые элементы, allLineElements - только поднимаемые эелменты\r\n            }\r\n\r\n            let columnsBefore = []; // все затронутые элементы по колонкам (включая поднимаемые)\r\n            const columnsAfter = [];       // с сортировкой: сначала поднимаемые, потом падающие\r\n            const ordersToDrop = [];       // только падающие\r\n\r\n            let id = 0;\r\n            for (let row = 0; row < rows; row++) {\r\n                for (let col = 0; col < cols; col++) {\r\n\r\n                    const isAffected = above.includes(id) || matched.includes(id);\r\n\r\n                    if (isAffected) {\r\n                        if (!columnsBefore[col]) columnsBefore[col] = [];\r\n                        columnsBefore[col].push(id); // добавляем в колонку\r\n                    }\r\n\r\n                    id++;\r\n                }\r\n            }\r\n            // Удалим пустые колонки в начале (если есть)\r\n            columnsBefore = columnsBefore.filter(col => Array.isArray(col) && col.length > 0);\r\n            // Собираем columnsAfter\r\n            let ordersToUp = []\r\n            for (const col of columnsBefore) {\r\n                const toLift = [];\r\n                const toDrop = [];\r\n                const bomb = [];\r\n                for (const id of col) {\r\n                    if (matched.includes(id) && !bombs.includes(id)) {\r\n                        toLift.push(id); // надо поднять\r\n                        ordersToUp.push(id)\r\n                    }\r\n                    else if (matched.includes(id) && bombs.includes(id)) {\r\n                        bomb.push(id) // бомба\r\n                        ordersToUp.push(id)\r\n                    }\r\n                    else {\r\n                        toDrop.push(id); // надо уронить\r\n                        ordersToDrop.push(id);\r\n                    }\r\n                }\r\n\r\n                if (bomb.length > 0) { columnsAfter.push([...toLift, ...toDrop, ...bomb]); }\r\n                else { columnsAfter.push([...toLift, ...toDrop]); }\r\n                // columnsAfter.push([...toLift, ...toDrop]);\r\n\r\n            }\r\n\r\n            const newBombOrders = [];\r\n\r\n            bombs.forEach((bombValue) => {\r\n                for (let row = 0; row < columnsAfter.length; row++) {\r\n                    const colIndex = columnsAfter[row].indexOf(bombValue);\r\n                    if (colIndex !== -1) {\r\n                        const originalOrder = columnsBefore[row][colIndex];\r\n                        newBombOrders.push(originalOrder);\r\n                        break; // нашли нужное значение, дальше не ищем\r\n                    }\r\n                }\r\n            });\r\n\r\n       \r\n\r\n            let topMatches = [];\r\n            matchedOrders = matchedOrders.flat()\r\n\r\n            if (columnsAfter.length > 1) {\r\n                for (let i = 0; i < columnsAfter.length; i++) { // мракобесие, которое находит столбы, где ничего не надо поднимать и заменять\r\n                    const afterFlat = columnsAfter[i];\r\n                    const beforeFlat = columnsBefore[i];\r\n\r\n                    const isSame =\r\n                        afterFlat.length === beforeFlat.length &&\r\n                        beforeFlat.length > 2 &&\r\n                        afterFlat.every((el, idx) => el === beforeFlat[idx]) &&\r\n                        afterFlat.every(el => matchedOrders.includes(el));\r\n    \r\n                    if (isSame) {\r\n                        topMatches = topMatches.concat(afterFlat);\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            // }// ЕСЛИ ПОДНИМАТЬ НЕЧЕГО, НУЖНО ТОЛЬКО ПОМЕНЯТЬ\r\n            if (ordersToDrop.length === 0) {\r\n                for (let i = ordersToUp.length - 1; i >= 0; i--) {// вырезание из \"поднимаемых\" элементов старые индексы бомб, чтобы у них не включалась невидимость\r\n                    if (bombs.includes(ordersToUp[i])) {\r\n                        ordersToUp.splice(i, 1);\r\n                    }\r\n                }\r\n            }\r\n\r\n    \r\n            this.synchronize(arr)\r\n\r\n            if (ordersToDrop.length === 0) {\r\n                const newBombOrders = [];\r\n                bombs.forEach(bombIndex => {\r\n                    const column = columnsBefore.find(col => col.includes(bombIndex));\r\n                    if (!column || column.length === 0) {\r\n                        console.warn(\"Бомба в пустоте или колонка не найдена:\", bombIndex);\r\n                        return;\r\n                    }\r\n                    const newBombIndex = column[column.length - 1];\r\n                    newBombOrders.push(newBombIndex);\r\n                });\r\n                newBombOrders.forEach((el, i) => {\r\n                    arr[el] = arr[bombs[i]]\r\n                })\r\n\r\n                if (Math.max(...matchedOrders) > this.cols) { // чтобы cоздавалась бомба в горизотальном ряду первой строчки\r\n                    newBombOrders.forEach((el, i) => {\r\n                        ordersToUp = ordersToUp.filter((n) => { return n != el });\r\n                        ordersToUp.push(bombs[i]) // УБИРАЮ ВЫШЕ, ЧТОБЫ ПОТОМ ЗАПУШИТЬ? ГЕНИАЛЬНО!!!\r\n                    })\r\n                }\r\n\r\n\r\n                if (bombs.length === 2 && Math.abs(bombs[0] - bombs[1]) === this.cols) {\r\n                    ordersToUp = ordersToUp.filter(item => !bombs.includes(item));\r\n                }\r\n\r\n\r\n                //НУЖНО БЫЛО В СЛУЧАЕ 2 СТОЛБЦОВ, УПИРАЮЩИХСЯ В ПОТОЛОК, ПРИ СОВПАДЕНИИ КОТОРЫХ ДРУГ С ДРУГОМ ОБРАЗОВЫВАЛИСЬ 2 БОМБЫ\r\n                const Y = []\r\n                const lastW = Math.max(...bombs);\r\n                const R = [];\r\n                columnsBefore.forEach(row => {\r\n                    row.forEach(num => {\r\n                        if (num > lastW) {\r\n                            Y.push(num);\r\n                        }\r\n                    });\r\n                });\r\n\r\n                //НУЖНО БЫЛО В СЛУЧАЕ 2 СТОЛБЦОВ, УПИРАЮЩИХСЯ В ПОТОЛОК, ПРИ СОВПАДЕНИИ КОТОРЫХ ДРУГ С ДРУГОМ ОБРАЗОВЫВАЛИСЬ 2 БОМБЫ\r\n\r\n\r\n        \r\n                const x = this.fillNewElements(arr, ordersToUp)\r\n\r\n\r\n                return {\r\n                    arr: x,\r\n                    newOrdersOfMatchedElements: ordersToUp,\r\n                    bombs,\r\n                    newBombOrders,\r\n                    Y,\r\n                    columnsBefore: columnsBefore.flat(),\r\n                    columnsAfter: columnsAfter.flat(),\r\n                }\r\n            }\r\n\r\n            else {\r\n\r\n\r\n                const x = this.makeColumns(columnsBefore.flat(), columnsAfter.flat(), arr, topMatches)\r\n\r\n                return {\r\n                    arr: x.arr,\r\n                    newOrdersOfMatchedElements: x.newOrdersOfMatchedElements,\r\n                    ordersToDrop,\r\n                    ordersToUp,\r\n                    columnsBefore: columnsBefore.flat(),\r\n                    columnsAfter: columnsAfter.flat(),\r\n                    bombs,\r\n                    newBombOrders\r\n                }\r\n\r\n            }\r\n        };\r\n        // this.findBombs = function (arr) {\r\n        //     const bombOrders = [];\r\n\r\n        //     arr.forEach((element, index) => {\r\n        //         if (this.bombTypes.includes(element)) {\r\n        //             bombOrders.push(index);\r\n        //         }\r\n        //     });\r\n        //     return bombOrders\r\n        // }\r\n\r\n        this.makeColumns = function (columnsBefore, columnsAfter, arr, topMatches) {\r\n\r\n            // console.log('444444444444444444444444444444444444444444444444444')\r\n            // for (let r = 0; r < this.rows; r++) {\r\n            //     const row = arr.slice(r * this.cols, (r + 1) * this.cols);\r\n            //     console.log(row.join(' '));\r\n            // }\r\n\r\n\r\n            const arrCopy = [...arr]; // защита от перезаписи\r\n            const forms = columnsAfter.map(order => arrCopy[order]);\r\n\r\n            columnsBefore.forEach((order, i) => {\r\n                arrCopy[order] = forms[i];\r\n            });\r\n\r\n\r\n            const newOrdersOfMatchedElements = []; // ЗАЧЕМ НУЖНА ЭТА ХЕРЬ??????????????????????????????????????????????????????????????????? она мешает в случае 2 горизонтальных бомб -- элементы над этими бомбами меняются-- НУЖНА В ПРИМЕРЕ 3, когда весь ряд стоит вертикально и упирается в потолок\r\n            topMatches.forEach((el, i) => {\r\n                if (!this.bombTypes.includes(arr[el])) { newOrdersOfMatchedElements.push(el) }\r\n            })\r\n\r\n            columnsBefore.forEach((order, i) => {\r\n                if (columnsAfter[i] > order && !this.bombTypes.includes(arr[order])) {\r\n                    newOrdersOfMatchedElements.push(order);\r\n                }\r\n            });\r\n\r\n\r\n            this.synchronize(arrCopy);\r\n\r\n            return {\r\n                arr: this.fillNewElements(arrCopy, newOrdersOfMatchedElements),\r\n                newOrdersOfMatchedElements,\r\n\r\n            };\r\n        };\r\n\r\n        this.fillNewElements = function (arr, newOrdersOfMatchedElements) {\r\n            // console.log('5555555555555555555555555555555555555555555555555555555555555555')\r\n            // for (let r = 0; r < this.rows; r++) {\r\n            //     const row = arr.slice(r * this.cols, (r + 1) * this.cols);\r\n            //     console.log(row.join(' '));\r\n            // }\r\n\r\n            // console.log(newOrdersOfMatchedElements)\r\n            newOrdersOfMatchedElements.forEach((order) => {\r\n                let form;\r\n                do {\r\n                    form = this.getSmartRandomForm(arr, this.amountOfTypesOfElements);\r\n                } while (this.willCauseMatch(arr, order, form, this.cols));\r\n\r\n                arr[order] = form;\r\n            });\r\n\r\n            // console.log('6666666666666666666666666666666666666666666666666666666666666666')\r\n            // for (let r = 0; r < this.rows; r++) {\r\n            //     const row = arr.slice(r * this.cols, (r + 1) * this.cols);\r\n            //     console.log(row.join(' '));\r\n            // }\r\n\r\n            this.synchronize(arr)\r\n            // console.log(arr)\r\n            return arr;\r\n        }\r\n\r\n        this.findAllMatches = function () {\r\n            const arr = this.getGridCopy();\r\n            const cols = this.cols;\r\n            const matchedGroups = [];\r\n\r\n            const checkHorizontal = (i) => {\r\n                const group = [i];\r\n                const row = Math.floor(i / cols);\r\n                let j = i + 1;\r\n                while (\r\n                    j < arr.length &&\r\n                    arr[j] === arr[i] &&\r\n                    Math.floor(j / cols) === row\r\n                ) {\r\n                    group.push(j);\r\n                    j++;\r\n                }\r\n                if (group.length >= 3 && !group.some(index => this.bombTypes.includes(arr[index]))) {\r\n                    return group;\r\n                }\r\n                return null;\r\n            };\r\n\r\n            const checkVertical = (i) => {\r\n                const group = [i];\r\n                const startVal = arr[i];\r\n                let j = i + cols;\r\n                while (\r\n                    j < arr.length &&\r\n                    arr[j] === startVal &&\r\n                    j % cols === i % cols\r\n                ) {\r\n                    group.push(j);\r\n                    j += cols;\r\n                }\r\n                if (group.length >= 3 && !group.some(index => this.bombTypes.includes(arr[index]))) {\r\n                    return group;\r\n                }\r\n                return null;\r\n            };\r\n\r\n            // Первый проход — горизонталь\r\n            for (let i = 0; i < arr.length; i++) {\r\n                const h = checkHorizontal(i);\r\n                if (h) matchedGroups.push(h);\r\n            }\r\n\r\n            // Второй проход — вертикаль\r\n            for (let i = 0; i < arr.length; i++) {\r\n                const v = checkVertical(i);\r\n                if (v) matchedGroups.push(v);\r\n            }\r\n\r\n            // Слияние пересекающихся групп\r\n            let merged = [];\r\n\r\n            for (const match of matchedGroups) {\r\n                let toMerge = [];\r\n                let rest = [];\r\n\r\n                for (const group of merged) {\r\n                    if (group.some(cell => match.includes(cell))) {\r\n                        toMerge.push(...group);\r\n                    } else {\r\n                        rest.push(group);\r\n                    }\r\n                }\r\n\r\n                merged = [...rest, [...new Set([...toMerge, ...match])]];\r\n            }\r\n\r\n            if (merged.length === 0) return [];\r\n\r\n            return this.checkForLines(arr, merged);\r\n        };\r\n\r\n        this.hasAnyPossibleMatch = function (arr) {\r\n            // console.log('Проверка на возможные ходы началась');\r\n            arr = arr || this.getGridCopy();\r\n            // const arr = this.getGridCopy();\r\n            const cols = this.cols;\r\n\r\n            const canSwap = (i1, i2) => {\r\n                const testArr = [...arr];\r\n                [testArr[i1], testArr[i2]] = [testArr[i2], testArr[i1]];\r\n                const matches = this.findMatchesInArray(testArr, cols) || [];\r\n                return matches.length > 0;\r\n            };\r\n\r\n            for (let i = 0; i < arr.length; i++) {\r\n                const right = i + 1;\r\n                const down = i + cols;\r\n\r\n                if (right % cols !== 0 && canSwap(i, right)) {\r\n                    // console.log('Есть хотя бы один возможный ход по горизонтали');\r\n                    return true; // нашёлся возможный ход по горизонтали\r\n                }\r\n\r\n                if (down < arr.length && canSwap(i, down)) {\r\n                    // console.log('Есть хотя бы один возможный ход по вертикали');\r\n                    return true; // нашёлся возможный ход по вертикали\r\n                }\r\n            }\r\n\r\n            // если потенциальных совпадений нет\r\n            return false;\r\n        };\r\n\r\n        this.findMatchesInArray = function (arr) { // найти все совпадения\r\n            const cols = this.cols\r\n            const matches = [];\r\n            const rows = Math.floor(arr.length / cols);\r\n\r\n            // Горизонтальные совпадения\r\n            for (let r = 0; r < rows; r++) {\r\n                for (let c = 0; c < cols - 2; c++) {\r\n                    const i = r * cols + c;\r\n                    if (arr[i] !== undefined && arr[i] === arr[i + 1] && arr[i] === arr[i + 2]) {\r\n                        matches.push([i, i + 1, i + 2]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Вертикальные совпадения\r\n            for (let c = 0; c < cols; c++) {\r\n                for (let r = 0; r < rows - 2; r++) {\r\n                    const i = r * cols + c;\r\n                    if (arr[i] !== undefined && arr[i] === arr[i + cols] && arr[i] === arr[i + 2 * cols]) {\r\n                        matches.push([i, i + cols, i + 2 * cols]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return matches;\r\n        };\r\n\r\n        this.smartReshuffleBoard = function () { // перемешать формы в случае отсутстия потенциальных совпадений\r\n            let flat = this.getGridCopy();\r\n            const cols = this.cols;\r\n            const maxAttempts = 5000;\r\n            let attempts = 0;\r\n\r\n            function swap(arr, i, j) {\r\n                const temp = arr[i];\r\n                arr[i] = arr[j];\r\n                arr[j] = temp;\r\n            }\r\n\r\n            function getRandomIndex(length) {\r\n                return Math.floor(Math.random() * length);\r\n            }\r\n\r\n            do {\r\n                const i = getRandomIndex(flat.length);\r\n                const j = getRandomIndex(flat.length);\r\n\r\n                if (i !== j) {\r\n                    swap(flat, i, j);\r\n                }\r\n\r\n                attempts++;\r\n            } while (!this.hasAnyPossibleMatch(flat) && attempts < maxAttempts);\r\n\r\n            this.synchronize(flat);\r\n            return flat\r\n        };\r\n\r\n        this.logGrid = function (arr, rows, cols) { // вывести массив гридом для дебага\r\n            if (!arr) {\r\n                arr = this.getGridCopy()\r\n            }\r\n            rows = this.rows\r\n            cols = this.cols\r\n            // for (let r = 0; r < rows; r++) {\r\n            //     const row = arr.slice(r * cols, (r + 1) * cols);\r\n            //     console.log(row.join(' '));\r\n            // }\r\n        }\r\n\r\n        this.explodeBomb = async function (startOrder, startPower, arr = null) {\r\n            const replaceWith = 'KABOOM!';\r\n            const cols = this.cols;\r\n            const rows = this.rows;\r\n            const bombTypes = Object.keys(this.bombConfigs);\r\n            const result = [];\r\n\r\n            if (!arr) {\r\n                arr = this.getGridCopy();\r\n            }\r\n\r\n            const startRow = Math.floor(startOrder / cols);\r\n            const startCol = startOrder % cols;\r\n\r\n            // Сбор всех поражённых ячеек вокруг бомбы\r\n            for (let dRow = -startPower; dRow <= startPower; dRow++) {\r\n                for (let dCol = -startPower; dCol <= startPower; dCol++) {\r\n                    const newRow = startRow + dRow;\r\n                    const newCol = startCol + dCol;\r\n\r\n                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {\r\n                        const newOrder = newRow * cols + newCol;\r\n                        if (newOrder !== startOrder) {\r\n                            result.push(newOrder);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Определяем новые бомбы\r\n            const newBombs = result.filter(order => bombTypes.includes(arr[order]));\r\n\r\n            // Анимация\r\n            await myModuleView.animateBomb(startOrder);\r\n            const normalOrders = result.filter(order => !bombTypes.includes(arr[order]));\r\n\r\n            await myModuleView.animateAffected(normalOrders);\r\n\r\n            // Удаление из модели\r\n            const ordersToEmpty = [...normalOrders, startOrder];\r\n            ordersToEmpty.forEach(order => arr[order] = replaceWith);\r\n\r\n            // Каскадные взрывы\r\n            let cascaded = [];\r\n\r\n            if (newBombs.length > 0) {\r\n                const results = await Promise.all(\r\n                    newBombs.map(bombOrder => {\r\n                        const bombType = arr[bombOrder];\r\n                        const bombPower = this.bombConfigs[bombType]?.power || 1;\r\n                        return this.explodeBomb(bombOrder, bombPower, arr);\r\n                    })\r\n                );\r\n                cascaded = results.flat();\r\n            }\r\n\r\n            const allKABOOMed = [...ordersToEmpty, ...cascaded];\r\n\r\n            // Отладка\r\n            // for (let r = 0; r < this.rows; r++) {\r\n            //     const row = arr.slice(r * cols, (r + 1) * cols);\r\n            //     console.log(row.join(' '));\r\n            // }\r\n\r\n            this.synchronize(arr)\r\n            // Обработка падений\r\n\r\n            return allKABOOMed;\r\n        };\r\n\r\n        this.raiseKABOOMedElements = async function (ordersToRaise) {\r\n            const arr = this.getGridCopy()\r\n            const cols = this.cols;\r\n            const rows = this.rows;\r\n            const columnsMap = new Map();\r\n            const newUpped = [];\r\n            // Сначала соберём все order-колонки, в которых что-то должно подняться или упасть\r\n            ordersToRaise.forEach(order => { // все колонки, в которых будет что-то меняться\r\n                const col = order % cols;\r\n                if (!columnsMap.has(col)) {\r\n                    columnsMap.set(col, []);\r\n                }\r\n                columnsMap.get(col).push(order);\r\n            });\r\n\r\n            // Теперь можно по этим колонкам собрать все индексы в этих колонках\r\n            let columns = [];\r\n\r\n            columnsMap.forEach((ordersInCol, colIndex) => {// все эти колонки с индексами\r\n                const column = [];\r\n                for (let row = 0; row < rows; row++) {\r\n                    const index = row * cols + colIndex;\r\n                    column.push(index);\r\n                }\r\n                columns.push(column);\r\n            });\r\n\r\n\r\n            const after = []\r\n            const before = []\r\n            columns.forEach((column, columnIndex) => {// собираем колонки after с учётом возможножного наличия расстояния между взорванными клетками\r\n                let upper = []\r\n                let kaboomed = []\r\n                let isKaboom = false\r\n                let maybeBottom = []\r\n                column.forEach((element, elementIndex) => {\r\n                    if (!ordersToRaise.includes(element) && !isKaboom) {\r\n                        upper.push(element)\r\n                    }\r\n                    if (ordersToRaise.includes(element)) {\r\n                        if (maybeBottom.length > 0) {\r\n                            upper = [...upper, ...maybeBottom]\r\n                            maybeBottom = []\r\n                        }\r\n                        isKaboom = true\r\n                        kaboomed.push(element)\r\n                    }\r\n                    if (!ordersToRaise.includes(element) && isKaboom) {\r\n                        maybeBottom.push(element)\r\n                    }\r\n                })\r\n                after.push([...kaboomed, ...upper])\r\n            })\r\n\r\n\r\n            for (let i = 0; i < after.length; i++) {\r\n                before.push([])\r\n                for (let j = 0; j < after[i].length; j++) {\r\n                    before[i].push(columns[i][j])\r\n                }\r\n            }\r\n\r\n            const newArr = [...arr]\r\n            for (let i = 0; i < after.length; i++) {\r\n                for (let j = 0; j < after[i].length; j++) {\r\n                    if (after[i][j] > before[i][j]) { newUpped.push(before[i][j]) }\r\n\r\n\r\n                    arr[before[i][j]] = newArr[after[i][j]]\r\n                    // else { break; }\r\n                }\r\n            }\r\n         \r\n\r\n\r\n\r\n            // for (let r = 0; r < this.rows; r++) {\r\n            //     const row = arr.slice(r * this.cols, (r + 1) * this.cols);\r\n            //     console.log(row.join(' '));\r\n            // }\r\n\r\n\r\n\r\n\r\n\r\n            this.synchronize(arr)\r\n            return { newUpped, before: before.flat(), after: after.flat() }\r\n        };\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    /* -------- end model -------- */\r\n    /* ----- begin controller ---- */\r\n    function ModuleController() {\r\n        let myModuleContainer = null;\r\n        let myModuleModel = null;\r\n        let myModuleView = null;\r\n        this.cols = 0;\r\n        this.rows = 0;\r\n        this.isAnimating = false;\r\n\r\n        this.init = function (container, model, view) {\r\n            myModuleContainer = container;\r\n            myModuleModel = model;\r\n            myModuleView = view;\r\n            this.createObserver();\r\n            window.addEventListener(\"hashchange\", this.updateState);\r\n            this.updateState();\r\n        };\r\n\r\n        this.updateState = function () {\r\n            const hashPageName = location.hash.slice(1).toLowerCase();\r\n            myModuleModel.updateState(hashPageName);\r\n        };\r\n\r\n        this.createObserver = function () {\r\n            const observer = new MutationObserver(() => {\r\n                const playfield = document.querySelector('.playfield');\r\n                if (playfield) this.bombClickHandler(playfield)\r\n                if (playfield && !playfield.dataset.initialized) {\r\n                    this.cols = +playfield.getAttribute('cols');\r\n                    this.rows = +playfield.getAttribute('rows');\r\n                    playfield.dataset.initialized = 'true';\r\n                    this.setupPlayfield(playfield);\r\n                }\r\n            });\r\n            observer.observe(document.body, { childList: true, subtree: true, attributes: true });\r\n        };\r\n\r\n        this.setupPlayfield = function (playfield) {\r\n            playfield.addEventListener('pointerdown', this.handlePointerDown.bind(this));\r\n            playfield.addEventListener('click', this.handleBombClick.bind(this));\r\n        };\r\n\r\n        this.handlePointerDown = function (event) {\r\n            if (this.isAnimating || (event.pointerType !== 'mouse' && event.pointerType !== 'touch')) return;\r\n\r\n            const startEl = event.target.closest('[form]');\r\n            if (!startEl) return;\r\n\r\n            const playfield = document.querySelector('.playfield');\r\n\r\n            let startOrder = parseInt(startEl.style.order); // сохраняем стартовый order внутри функции и он остаётся доступен\r\n\r\n            const onPointerMove = (moveEvent) => {\r\n                const endEl = moveEvent.target.closest('[form]');\r\n                if (!endEl) return;\r\n\r\n                const endOrder = parseInt(endEl.style.order);\r\n\r\n                const diff = Math.abs(startOrder - endOrder);\r\n                const startRow = Math.floor(startOrder / this.cols);\r\n                const endRow = Math.floor(endOrder / this.cols);\r\n\r\n                const isLeftOrRight = diff === 1 && startRow === endRow;\r\n                const isVertical = diff === this.cols;\r\n\r\n                if (isLeftOrRight || isVertical) {\r\n                    playfield.removeEventListener('pointermove', onPointerMove);\r\n                    this.processSwipe(startOrder, endOrder); // вызываем свайп с сохранённым startOrder\r\n                }\r\n            };\r\n\r\n            playfield.addEventListener('pointermove', onPointerMove);\r\n            playfield.addEventListener('pointerup', () => playfield.removeEventListener('pointermove', onPointerMove), { once: true });\r\n            playfield.addEventListener('mouseleave', () => playfield.removeEventListener('pointermove', onPointerMove), { once: true });\r\n        };\r\n\r\n        this.bombClickHandler = function (playfield) {\r\n\r\n            if (playfield._bombClickHandlerInitialized) return; // если уже есть - не вешаем второй раз\r\n            playfield._bombClickHandlerInitialized = true;\r\n\r\n            playfield.addEventListener('click', async (event) => {\r\n                const target = event.target.closest('[form]');\r\n                if (!target) return;\r\n\r\n                const formType = target.getAttribute('form');\r\n\r\n                if (formType === 'bomb1' || formType === 'bomb2') {\r\n                    const bombOrder = parseInt(target.style.order);\r\n                    const bombPower = formType === 'bomb1' ? 1 : 2;\r\n\r\n                    const explodedBombs = await myModuleModel.explodeBomb(bombOrder, bombPower);\r\n\r\n                    const raiseKABOOMedElements = await myModuleModel.raiseKABOOMedElements(explodedBombs);\r\n\r\n                    let arr = myModuleModel.getGridCopy()\r\n\r\n                    arr = myModuleModel.fillNewElements(arr, raiseKABOOMedElements.newUpped)\r\n                    await this.processUntilNoMatches(); // СОМНИТЕЛЬНО\r\n\r\n                    await myModuleView.animateFallAndRise(0, 0, raiseKABOOMedElements.before, raiseKABOOMedElements.after);\r\n                    await myModuleView.addNewElements(arr, raiseKABOOMedElements.newUpped);\r\n\r\n                    \r\n                    console.log('--------------------------------------------');\r\n                  for (let r = 0; r < this.rows; r++) {\r\n                const row = arr.slice(r * this.cols, (r + 1) * this.cols);\r\n                console.log(row.join(' '));\r\n            }\r\n                    console.log('--------------------------------------------');\r\n                }\r\n                //khoh\r\n            });\r\n        };\r\n\r\n        this.processSwipe = async function (startOrder, endOrder) {\r\n\r\n            const result = myModuleModel.swipe(startOrder, endOrder);\r\n            if (!result) return myModuleView.showNoSwipes(startOrder, endOrder);\r\n\r\n            const { arr, newOrdersOfMatchedElements, ordersToDrop, ordersToUp, columnsBefore, columnsAfter, bombs, newBombOrders, Y } = result;\r\n            // console.log('ordersToUp:' + ordersToUp)\r\n            // console.log(newOrdersOfMatchedElements)\r\n            await myModuleView.showSwipes(startOrder, endOrder);\r\n\r\n            if (bombs.length > 0) await myModuleView.addBombs(arr, bombs, newBombOrders);\r\n\r\n            if (ordersToDrop) {\r\n\r\n                // console.log('ordersToDrop:' + ordersToDrop)\r\n                // console.log('ordersToUp:' + ordersToUp)\r\n                // console.log('columnsBefore:' + columnsBefore)\r\n                // console.log('columnsAfter:' + columnsAfter)\r\n\r\n                await myModuleView.animateFallAndRise(ordersToDrop, ordersToUp, columnsBefore, columnsAfter);\r\n            }\r\n            if (!ordersToDrop && bombs.length > 0) {\r\n\r\n                await myModuleView.animateFallAndRise(0, Y, columnsBefore, columnsAfter);\r\n\r\n            }\r\n\r\n            if (newOrdersOfMatchedElements) {\r\n                await myModuleView.addNewElements(arr, newOrdersOfMatchedElements);\r\n            }\r\n\r\n            await this.processUntilNoMatches();\r\n\r\n            if (!myModuleModel.hasAnyPossibleMatch()) {\r\n                const reshuffledArr = await myModuleModel.smartReshuffleBoard();\r\n                myModuleView.redrawBoard(reshuffledArr);\r\n            }\r\n\r\n            console.log('---------------------------------------------------');\r\n        for (let r = 0; r < this.rows; r++) {\r\n                const row = arr.slice(r * this.cols, (r + 1) * this.cols);\r\n                console.log(row.join(' '));\r\n            }\r\n            console.log('------------------------------------------');\r\n\r\n        };\r\n\r\n        this.processUntilNoMatches = async function () {\r\n            let found;\r\n            do {\r\n                found = await this.processOneMatchCycle();\r\n            } while (found);\r\n        };\r\n\r\n        this.processOneMatchCycle = async function () {\r\n            const match = myModuleModel.findAllMatches();\r\n            if (!match) return false;\r\n\r\n            const { arr, newOrdersOfMatchedElements, ordersToDrop, ordersToUp, columnsBefore, columnsAfter, bombs, newBombOrders, Y } = match;\r\n            if (bombs && bombs.length > 0) await myModuleView.addBombs(arr, bombs, newBombOrders);\r\n            if (ordersToDrop) {\r\n                await myModuleView.animateFallAndRise(ordersToDrop, ordersToUp, columnsBefore, columnsAfter);\r\n            }\r\n\r\n            if (newOrdersOfMatchedElements) {\r\n                await myModuleView.addNewElements(arr, newOrdersOfMatchedElements);\r\n            }\r\n\r\n            return !!(ordersToDrop || newOrdersOfMatchedElements);\r\n        };\r\n\r\n        this.handleBombClick = function (event) {\r\n            const target = event.target;\r\n            if (target.hasAttribute('bomb')) {\r\n                const order = Number(target.style.order);\r\n                console.log(`Бомба активирована на клетке ${order}`);\r\n                // Здесь потом вызовешь свою функцию взрыва\r\n            }\r\n        };\r\n    }\r\n    /* ------ end controller ----- */\r\n\r\n    return {\r\n        init: function (container) {\r\n            // @TODO: add validation of `container`\r\n            this.main(container);\r\n\r\n            const view = new ModuleView();\r\n            const model = new ModuleModel();\r\n            const controller = new ModuleController();\r\n\r\n            //связываем части модуля\r\n            view.init(document.getElementById(container));\r\n            model.init(view);\r\n            controller.init(document.getElementById(container), model, view);\r\n        },\r\n\r\n        main: function (container) {\r\n            //предварительно что-то можно сделать\r\n            console.log(`Иницилизируем SPA для контейнера \"${container}\"`);\r\n        },\r\n    };\r\n\r\n}());\r\n/* ------ end app module ----- */\r\n\r\n/*** --- init module --- ***/\r\ndocument.addEventListener(\"DOMContentLoaded\", mySPA.init(\"root\")); // инициализируем модуль как только DOM готов.\n\n//# sourceURL=webpack://remi_match3_game/./src/index.js?");

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./style.css */ \"./node_modules/css-loader/dist/cjs.js!./src/style.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://remi_match3_game/./src/style.css?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;